# 本書の読み方

## ワード名 - 正規名と短縮名
本文書で説明しているワードは、
デフォルトで使用可能なもののみです。
これらのワードは標準ボキャブラリ std に所属しています。
しかし本文書ではボキャブラリ名を含んだ正規名ではなく、
短縮名を記載しています。
例えば加算を実施するワードの正規名は std:+ ですが、
単にワード + として説明を行っています。

Paraphrase のボキャブラリは Forth におけるそれとは
完全に同一ではありません。
Paraphrase におけるボキャブラリは C++ などにおける
名前空間に近いものです。
ボキャブラリに関する詳しい説明については後にリリースされる
であろう Paraphrase のプログラミングガイドを参照して下さい。

## ワード名 - 接頭詞など
Paraphrase にて標準的に利用できるワードには
&gt; や @ といった接頭詞が用いられています。
&gt; など Forth 由来のものもあります。

以下に示すこれらは、あくまでも名付けの段階における
文化的な決まりのようなものであり、
特定の接頭詞や接尾詞が付いているからといって
言語システム側で何か特別な機能が付加されるわけではありません。
Paraphrase はユーザー側でも独自にワードを定義できる
機能を有しています。
そのため、もしここで説明する名前付けの文化に賛同し
協力してくれるのであれば
ユーザー各自で同様の接頭詞・接尾詞を与えて
命名していただければ幸いです。

### &gt;
&gt; は大小関係を調べる不等号の働きをする
ワードとしても存在していますが、
pipe や r などといった字句とも合わせて使用されます。
このような場合、例えば '&gt;pipe' や 'pipe&gt;' などと
いったものは to-pipe や from-pipe といった読み方をします。
このような考え方は Forth の文化から拝借しています。

to-pipe と読むワード &gt;pipe はスタックにあるデータを
パイプに渡す、という意味を持つワードです。
同様に from-pipe と読むワード pipe&gt; は
パイプからデータを取り出す、という意味を持つワードとなります。
後述しますが、Paraphrase にも Forth と同様
データスタックの他に利用できる
RS と呼ばれる補強スタックがあります。
to-R と呼ばれるワード &gt;r は
データスタックの最上部の値を取り出し、
RS に積むことを意味し、
from-R と呼ばれるワード r&gt; は
RS から値をひとつ取り出しデータスタックへと積む処理を
行います。
to- , from- といった接頭詞や接尾詞を表す記号
&gt; についてはこのような意味を与えています。
繰り返しになりますが、これらはあくまでも名前を付ける際の
「お約束」のようなものであり、
Paraphrase の言語処理系が何か特別な処理
--- 例えば「&gt; で始まるワード名だから、
データの移動に用いられるワードである」等とは
認識しないことに注意して下さい。

### @
いくつかのワードについてはその名前が @ で始まっています。
これらのワードは原則として先頭の @ を除くと
同名のワードが存在します。
@ が付かないものと付くものの違いは
付かないものはスタック上の値を消費しますが、
@ が付くものは消費しません。

@ より始まるワード名を持つものは先頭の @ を取り除いた
同名のワードの「<[ref reference-type-word 参照型]>」と
呼ばれます。
例えば &gt;r というワードは
データスタックの一番上にある値を取り出し、
その値を補強スタックに積むワードですが、
@&gt;r というワードはデータスタックから値を取り出さず
一番上の値を「見るだけ」に止めその値と同じものを
補強スタックに積むワードとなります。

@ による接頭語はあくまでもワード名に関する
指標のようなものです。
上で説明した &gt; と同様、
システム的に制限・強要されているものではありません。
ワード名を @ から開始したからといってスタックを
消費しないワードに自動的に変換されることはありません。

スタックを消費しないワードの名前が必ずしも
@ から始まるということではありません。
スタックの現在の状況を表示する show などがその例です。
@ という記号はあくまでも @ が付くものと付かないワードが
共に存在する場合に限りスタックを消費しないバージョンで
あることを命名規則として示しているだけです。
そしてこの命名規則はできるだけ守るようにしたく
思いますしユーザーの皆さんにも守って欲しいと思いますが、
何ら拘束力はありません。
そのため、必ずしもこの命名規則が守られない場合があることに
注意して下さい。

繰り返しになりますが、
標準ワードに関してはこのような命名規則を
運用上のルールとして規定しています。
ユーザー定義のワードにおいても考慮して
いただけると助かります。
もちろん強要はいたしませんが、
現段階における Paraphrase の文化というか
推奨コーディングルールのようなものですので
協力していただければ助かります。

### 並列処理関連ワードの接頭詞・接尾詞について
並列処理は Paraphrase の特徴と密接に関係するものです。
複数のスレッド間での情報のやり取りが Paraphrase での
プログラミングにおいては特に重要となります。

各スレッドにおける情報の授受の関係は
複雑なグラフネットワークを構築し得ます。
Paraphrase では、これら複雑なスレッド同士の情報の授受に
おける繋がりを並列処理関連ワードの接頭詞・接尾詞を
用いて簡潔に表現することを試みています。
ここではそれら接頭詞・接尾詞について説明を行います。
以後この小節においては、特に断りが無い限り
並列処理関連ワードに関する接頭詞・接尾詞につして
言及しているものとします。

#### 並列処理関連ワードの接頭詞・接尾詞は熟語的
並列処理とは関係なく説明した接頭詞・接尾詞では、
それら単体で意味を持つような説明を行いました。
しかし、並列処理に関係するワードの接頭詞・接尾詞については
複数の接頭詞・接尾詞を組み合わせて意味を構成する場合もあり、
ある意味「熟語的」な接頭詞・接尾詞になっています。

例えば &gt; と = という接尾詞があります。
また =&gt; という接尾詞も存在します。
この接尾詞は = と &gt; を組み合わせた意味を持つ接尾詞です。
ここで注意しなければならないことは &gt;&gt; という接尾詞も
存在することです。
熟語的に考えるのであれば、
接尾詞 &gt; を 2 つ組み合わせた意味を持つ
接尾詞である…と考えるのが自然かと思います。
しかしこの場合は &gt;&gt;という単独な接尾詞が存在し、
熟語的な解釈はしてはいけない状況となります。

熟語的な解釈については、熟語を構成する単一の
接頭詞・接尾詞について理解をしていただければ
特に混乱は生じないと思いますので、
まずはそれらから説明を行います。

なお他の接頭詞・接尾詞と同様、
ここで説明するものについてもあくまでも名前付けの
規約の様なものであり、言語システムとして
何ら特別な取り計らいを行うものではありません。

##### &gt;
スレッドを生成するコンテキストのデフォルトのチャネルに
接続することを意味します。

接頭詞に用いた場合（例えばワード &gt;[ 等）は、
これから定義し実行するスレッド（子スレッド）の
デフォルトの読み込み用チャネルに、
現在のスレッド（親スレッド）のデフォルトの書き込み用チャネル
を接続することを意味します。

接頭詞に用いた場合（例えばワード ]&gt; 等）は、
定義を完了しこれから生成・実行されるスレッド（子スレッド）の
デフォルトの書き込み用チャネルを、
現在のスレッド（親スレッド）のデフォルトの
読み込み用チャネルに接続することを意味します。

言葉で記すと想像しづらいかもしれませんが、
並列処理においても接頭・接尾における &gt; という記号が有する
to と from という意味を想像していただければ
理解しやすいのではないかと思います。
参考までに以下に使用例を記しておきます。
<[code-begin]>
&gt; reset-pipes 
&gt; &gt;[ while-pipe "RECV=" . .cr repeat "QUIT" .cr ] 
  ok.
&gt; 1 5 for+ i &gt;pipe next
  ok.
RECV= 1
RECV= 2
RECV= 3
RECV= 4
&gt; eoc &gt;pipe
QUIT
  ok.
<[code-end]>

##### &gt;&gt;
接頭詞として用いられる場合は、
TOS に積まれてあるチャネルとこれから生成する
スレッドのデフォルトの読み込み用チャネルを接続するという
意味になります。

接尾詞として用いられる場合は、
現在定義中のスレッド（小スレッド）のデフォルトの
書き込み用チャネルをスレッド生成後にデータスタックに積む
ことを意味します。

接尾詞・接頭詞として使用される場合には
<[code-begin]>
[ ... ]&gt;&gt; &gt;&gt;[ ... ]
<[code-end]>
等となり、対を成すような形で使用できます。

##### =
接尾詞で用いられる = は生成したスレッドのコンテキストを
（データ）スタックに積むことを意味します。
熟語的に利用される場合もあり、
例えば ]=&gt;&gt; というワードでは、
生成したスレッドのコンテキストとチャネルを
スタックに積みこみます。
スタックに積み込む順序は接尾詞を左から右に読んだ時と
同じとなり、最初にコンテキストを積み、
次にチャネルを積みます。

## 値について
後述しますが Paraphrase における重要な概念として
値とワードが存在します。
ワードは他のプログラミング言語における
関数やサブルーチン、マクロのようなものです。
値については、整数値や文字列など、
スタックや変数に格納可能な情報を指すものとします。
ここではどのような種類の値が存在するのか、
つまり、値に関する型について説明を行います。

### 数値型
整数や浮動小数点などの型が存在します。
整数にはそれぞれの環境で自然な整数型として
取り扱うことのできる <[ref int int]> や
int 以上の情報量を取り扱うことのできる
<[ref long long]> 型が存在します。
その他、多数のメモリを用いて表現される
多倍長整数を表す <[ref big-int big-int]> があります。

浮動小数点型については、
単精度浮動小数点型の <[ref float float]> 型と
倍精度浮動小数点型の <[ref double double]> 型があります。

### 文字列型
Paraphrase にも他のプログラミング言語と同様に
文字列を表す文字列型が存在します。
文字列型はダブルクォーテーションまたは
シングルクォーテーションで囲まれたものと、
ワード &lt;&lt;&lt; と &gt;&gt;&gt; 等を用いて表される
ヒアドキュメントが存在します。

### シンボル
Paraphrase では文字列の他にシンボルという値が存在します。
例えば ( apple banana cherry ) というリストにおける
apple 等がシンボルです。
スタックに直接シンボルを積む場合は
`banana 等、バッククォートで始まるものを利用して下さい
（ただし、数字で始まってはいけない等、
いくつか制限があります）。

### 真偽値
比較演算の結果等を示すために真または偽の値を
取り扱うことができます。
この値は数値や文字列とは異なり、
直接値をスタックに積むことはできません。
ただ、true または false というワードの実行結果として
希望する真偽値をスタックに積むこともできます。

### ワード
ワードを表す値です。
無名ワード（ラムダ）なども表すことが可能です。

### ファイル
ファイルへの読み書きする場合、
対象のファイルを表す値です。

### EoF - End of File
ファイルの終端を表す値です。

### チャネル
スレッド間で情報を伝える通信路である
チャネルを表す値です。

### EoC - End of Channel
チャネルの終端を表す値です。
この値を通信チャネルに送信すれば、
そのチャネルは書き込みに関して閉じます。
また、あるチャネルから値を読み取ったとき、
この値が読み取られた場合、
そのチャネルは読み込みに対して閉じられたことを
意味します。

### アドレス
メモリの番地を意味する値です。
C のキャストによる型の変換や、
switch - dispatch における分岐処理の実現などに
利用されている値です。

### 無効な値
値として無効なことを示す値…などと書くと
「無効なことを示すためには有効な値」であるのでは？
という反論が来そうですが、
C 言語で言うところの NULL のような値のことです。
この値は invalid というワードの実行により
スタックに積むこともできます。

### コンテキスト
Paraphrase ではプログラムの実行に関する情報を
コンテキストと呼ばれる概念で管理しています。
コンテキストにはデータスタック等、
Paraphrase のプログラムで用いられる情報が
格納されています。

並列処理を行う場合、複数のスレッドが生成され、
それらがそれぞれに並列に実行されます。
この時、それぞれのスレッドに 1 つのコンテキストが
生成され紐づけされます。

このコンテキストは値として取り扱うことができ、
スタックに積むこともできます。

### 実行レベル
インタプリタモードやコンパイルモード等、
実行レベルを表す値です。

### 定義中のワード
現在定義中のワードを示す値です。

### コンパイル中のアドレス
次にコンパイルされるものが格納されるアドレスを
示す値です。

### 補助情報
コメントブロックやヒアドキュメントの実現等で
用いられる値です。

### 構文用制御ブロック情報
Paraphrase では、
ワードを構文のように取り扱えるようにするため、
構文用スタックを用意しています。
このスタックは現在は公開していない状況ですが、
将来的にはこれらもすべて
ユーザーに公開し、構文のようなワードも
公開されている情報からプログラム可能にしたいと思っています。
その構文スタックで利用される
制御ブロック情報に関する値です。

### 標準コードへのポインタ
アスペクト思考プログラミング（AOP）にて
利用する値です。

### コンテナ
各種の値を格納可能な情報の塊をコンテナと呼びます。
そのコンテナには配列、リスト、連想配列があります。
これらもそれぞれのコンテナの生成を行うワードの
実行を通じてスタックに積むことが可能です。

## スタックの変化
ワードの実行による実行前と実行後のスタックの変化は、
Forth にならい記号 --- を挟んで表現しています。
--- の左側がワードの実行前のスタックを表し、
右側がワードの実行後のスタックの状況を表しています。
それぞれのスタックの状況は左側がスタックの底に近い部分を表し、
右側がスタックの上の方を表しているものとします。
最も右側に書かれているものがスタックの最上部
(TOS=Top Of Stack）です。

例えば、+ というワードはスタックから 2 つの数値を取り出し、
それらの和をスタックに積みますので、
ワード + におけるスタックの変化は
「数値 数値 --- 数値」と表すことができます。
この文書では数値を表す記号 N を用いて、
N1 N2 --- N　などと表記することとします。
スタックの変化を説明するために使用される記号については、
後述する「スタック上の値を表す記号」を参照して下さい。

なお、Forth ではスタックの変化を示す情報は
(n1 n2 --- n3) 等と丸括弧で囲んで表記されることもあります。
Paraphrase においては、
特に必要のない限り両端の丸括弧は省略するものとします。

ワード <[ref size-at-intro size]> など、
複数の種類の値に対応するワードでは、
例えば TOS にある値について { A | S } --- I などという
表現を用いています。
中括弧 { } と縦線で構成される { A | S } という表記は
A または S という状態を表すこととします。

スタックの状態を示す際に
「<[ref RS RS]>:」という表記がある場合は
補強スタック（Reinforcement Stack）の状態を表すものとします。
Forth では RS はリターンスタックの意味でしたが、
Paraphrase では必ずしも復帰情報を保存するとは限らない…
という意味において補強スタックという名称を採用しています。

###_ ユーザーの入力とインタプリタの出力
<[u 1 2 + .]> のように下線がついている部分は
ユーザーが入力する部分を表しています。
下線が付いていない部分は Paraphrase インタプリタの出力です。

ワードの説明には使用例が付いているものもあります。
例えば以下のようなものです：
<[code-begin]>
&gt; <[u 1 2 + .]>
  3 ok.
<[code-end]>

１行目の &gt; は Paraphrase のインタプリタによる
プロンプトです。
2 行目の 3 ok. はインタプリタが出力したものです。

###_ スタック上の値を表す記号
ここではスタックの変化を表す際に利用する
記号について説明を行います。

<[dl-begin]>
<[dl-ref-item アルファベットの小文字]>
<[dd]>
任意の値を示します。
後述する記号 X と同じですが、
スタック上の順序が変化する場合などに使用します。
例えば a b --- b a という表記では
スタック上の 2 つの値が入れ替わっている様子を示しています。
<[/dd]>
<[dl-end]>

<[dl-table-begin]>
<[dl-table-ref-item A]>
<[ddt]>配列（array）を表します<[/ddt]>
<[dl-table-ref-item B]>
<[ddt]>真偽値（bool 型の値）を表します<[/ddt]>
<[dl-table-ref-item C]>
<[ddt]>標準コード（へのポインタ）を表します<[/ddt]>
<[dl-table-ref-item D]>
<[ddt]>
<[ref double-type-value 倍精度浮動小数点値]>
（<[ref double-type double]> 型の値）を表します<[/ddt]>
<[dl-table-ref-item E]>
<[ddt]>
<[ref float-type-value 単精度浮動小数点値]>
（<[ref float-type float]> 型の値）や倍精度浮動小数点値
もしくは
<[ref big-int-type-value 多倍長整数値]>の値を表します。
<[/ddt]>
<[dl-table-ref-item F]>
<[ddt]>単精度浮動小数点値（float 型の値）を表します。
<[/ddt]>
<[dl-table-ref-item G]><[ddt]>ファイルを表します。<[/ddt]>
<[dl-table-ref-item H]>
<[ddt]>キーと紐付けられた値を保持する連想配列を表します。
<[/ddt]>
<[dl-table-ref-item I]>
<[ddt]>整数型（integer 型）の値を表します。<[/ddt]>
<[dl-table-ref-item J]>
<[ddt]>多倍長整数型（big-int 型）の値を表します。<[/ddt]>
<[dl-table-ref-item K]>
<[ddt]>
整数値（int, long, big-int 型の値）を表します。
<[/ddt]>
<[dl-table-ref-item L]>
<[ddt]><[ref long-type-value 長整数型値]>
（<[ref long-type long]> 型の値）を表します。）
<[/ddt]>
<[dl-table-ref-item M]>
<[ddt]>
多倍長整数値(big-int)以外の数値
（int, long, float, double 型の値）を
表します。
<[/ddt]>
<[dl-table-ref-item N]>
<[ddt]>
任意の数値（int,long,big-int,float,double）を表します。
<[/ddt]>
<[dl-table-ref-item O]><[ddt]>無効な値を表します<[/ddt]>
<[dl-table-ref-item P]>
<[ddt]>チャネルの終端
（<[ref EoC EoC]> = End of Channel）を表します。
<[/ddt]>
<[dl-table-ref-item Q]><[ddt]>コンテキストを表します<[/ddt]>
<[dl-table-ref-item R]><[ddt]>リストを表します。<[/ddt]>
<[dl-table-ref-item S]><[ddt]>文字列を表します。<[/ddt]>
<[dl-table-ref-item T]><[ddt]>シンボルを表します。<[/ddt]>
<[dl-table-ref-item U]>
<[ddt]>
補助情報値を表します。この値は整数値です。
コメントブロックの状態やヒアドキュメントの
ブロック構造を示す値として使用します。
<[/ddt]>
<[dl-table-ref-item V]>
<[ddt]>
構文スタックに積む制御ブロック
（Control Block）情報を示します。
<[/ddt]>
<[dl-table-ref-item W]><[ddt]>ワードを表します。<[/ddt]>
<[dl-table-ref-item X]><[ddt]>任意の値を表します。<[/ddt]>
<[dl-table-ref-item Y]><[ddt]>チャネルを表します。<[/ddt]>
<[dl-table-ref-item Z]>
<[ddt]>ファイルの終端
（<[ref EoF EoF]> = End of File）を表します。
<[/ddt]>
<[dl-table-ref-item &alpha;]>
<[ddt]>アドレスを表します。<[/ddt]>
<[dl-table-ref-item &theta;]>
<[ddt]>実行レベルの閾値を表します。<[/ddt]>
<[dl-table-ref-item &pi;]>
<[ddt]>現在コンパイル中のスレッドにて、
次にコンパイルされるものが格納されるアドレスを示します。
<[/ddt]>
<[dl-table-ref-item &omega;]>
<[ddt]>現在定義中のワードを表します。
新たにワードを定義する場合は、
現在定義中のワード（これが ω で表されるものです）を
スタック上にプッシュするなどします
（new word とも呼ぶ場合もあります）。
<[/ddt]>
<[dl-table-end]>

###_ 略語
<[dl-begin]>
<[dl-ref-item DS]>
<[dd]>
データスタック(Data Stack)の意味です。
一般的に Paraphrase のワードは
このデータスタックから値を取り出し、
処理の結果もこのデータスタックに積みます（プッシュします）。
<[/dd]>
<[dl-ref-item RS]>
<[dd]>
補強スタックを表します。
Paraphrase は Forth 系言語であり、
Forth においては RS は return stack を意味していました。
これは文字通り呼び出し元に戻るための情報を主に格納する
スタックでした。
Paraphrase では呼び出したワードからの復帰のために
この補強スタックは利用していません。
Forth においては RS は return stack としての利用のみならず
もう一つのデータスタックとして補助スタックとしての
使い方もされていました。
Paraphrase でも補助スタックは必要であると考えつつ、
かつ、RS という Forth からの呼び名を残すため
Reinforcement Stack として存在させています
（とは言え現在の Paraphrase にはローカル変数も
ありますのでこの RS と呼ばれる補助スタックの必要性も
徐々に薄れていっているようにも感じます）。
なお ver. 0.96 までの Paraphrase ではこのスタックを
リターンスタック（return stack）や
補助スタックと呼んでいました。
<[/dd]>
<[dl-ref-item TOS]>
<[dd]>
Top Of the Stack の略です。
単に TOS と書かれている場合はデータスタックの
最上部（もしくは最上部に存在している値）を指します。
<[/dd]>
<[dl-ref-item IP]>
<[dd]>
インストラクションポインタ（Instruction Pointer）の意味です。
Paraphrase では Forth と同様にワードを構成する
ワードや値からなる列はスレッドに格納されています。
この格納されているワード列に対し、
次に実行すべきワードを指し示しているのが IP です。
IP は基本的に 1 つづつ増加し、
順次格納されているワードを実行していきます。
もちろん増分や変化には例外もあり、
この値を変更することにより分岐を実現することもできます。
<[/dd]>
<[dl-ref-item VM]>
<[dd]>
他の言語と同じく Virtual Machine の意味です。
別スレッドで実行される並列処理ブロック毎に VM が生成され、
各 VM 上で並列処理ブロックは実行されます。
各 VM はそれぞれ DS および RS 等を所有しています
（これをコンテキストと呼びます）。
VM は内部インタプリタと呼ばれる場合もあります。
<[/dd]>
<[dl-end]>

###_ 用語
<[dl-begin]>
<[dl-ref-item コンテキスト]>
<[dd]>
VM で操作される情報の塊またはそれらの情報を指します。
データスタック（DS）などの情報もコンテキストの一部です。
Paraphrase では並列実行される各スレッド毎に独立した
コンテキストが存在します。
チャネル通信に関する部分を覗いては
互いに独立して処理を進めます。
<[/dd]>
<[dl-ref-item データスタック]>
<[dd]>
Paraphrase には様々な種類のスタックがあります。
ユーザーがプログラムを作成する際に利用するスタックは
主にデータスタックを利用する場合が殆であり、
必要に応じて補強スタックを利用する状況になると推測しています。
データスタックの言語仕様としての定義はありません。
多くのワードが利用するスタックをデータスタックと呼んでいます。
例えば可算を行うのは + という名を持つワードですが、
そのワードが対象とするスタックは他の多くのワードが
処理の対象とするスタックです。
このスタックのことを Paraphrase では「データスタック」と
呼んでいます。
<[/dd]>
<[dl-ref-item スタック]>
<[dd]>
本文書では特に断りがない限りデータスタックのことを
単に「スタック」と呼びます。
<[/dd]>
<[dl-ref-item セカンド]>
<[dd]>
スタックの上から 2 番目の場所、
もしくはそこに格納されている値を指します。
対象のスタックについて特に言及が無い場合は
データスタックを指しているものとします。
<[/dd]>
<[dl-ref-item スレッド]>
<[dd]>
特に断りが無い場合は説明の対象となっているワードを
実行するスレッドを指します。
<[/dd]>
<[dl-ref-item 親スレッド]>
<[dd]>
特に断りがない場合は説明の対象となっているワードを
実行するスレッドの親スレッド
（当該スレッドを生成したスレッド）を指します。
<[/dd]>
<[dl-ref-item 子スレッド]>
<[dd]>
用語「親スレッド」と同様、
特に断りがない場合は説明の対象となっているワードを
実行するスレッドの子スレッド
（当該スレッドが生成したスレッド）を指します。
<[/dd]>
<[dl-end]>

